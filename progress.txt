   ?  questions to resolve
      - send pid of cloned process with flag CLONE_PARENT to new actual parent ?
      - draw a diagram consists of the elements: SID (session) , PID (process) , TID (thread)


   0. different features
      [a] clean_code_utils.h
      [b] enum_array.c


   1. c-programm, 1 file
   2. c-programm, main + (header, unit) files


   3. c-programm, main + (dinamic library = so) / compiletime shared library linkage
      [a] gcc -shared -fPIC ./source/c/unit.c -o ./lib/shared/libunit.so    # compile programm unit to shared library
      [b] gcc main.c -L./lib/shared -lunit                                  # -L<path> = path to .so, -l<name> = name of .so  
      [c] export LD_LIBRARY_PATH=./lib/shared/                              # before run programm = temporarily set path to shared library for OS

      ~ ldd <programm>   # programm dependencies of dynamic libraries


   4. c-program, main + (static library = a)
      [a] gcc -c ./source/c/unit.c -o ./source/c/unit.o                     # compile programm unit to object file 
      [b] ar rcs ./lib/static/libunit.a ./source/c/unit.o                   # pack .o into static library (might be several .o files simultaneously)
      [c] rm ./source/c/unit.o                                              # (optional) remove .o file
      [d] gcc main.c -L./lib/static -lunit                                  # -L<path> = path to .a, -l<name> = name of .a 


   5. makefile
      [a] syntax = target: dependencies
      [b] usage = make <target>
      [c] additional = 
         .PHONY                                          # target that doesn't name a file  
         <command>     ( without target and tab )        # will be executed independently
         CC=gcc        ( without target and tab )        # usage = $(CC)
      [d] attention ! every command executes in separate shell ! might be changed using .ONESHELL


   6. c-programm, main + (dinamic library = so) / runtime shared library linkage
      [a] gcc -shared -fPIC ./source/c/unit.c -o ./lib/shared/libunit.so               # compile programm unit to shared library
      [b] gcc main.c -ldl                                                              # dl = special system library for runtime linkage (dlopen, dlsym)  
      
      > attention ! if there are only lib name (not path) in dlopen(...) , should :  
        or use environment variable  =  `export LD_LIBRARY_PATH=<path>` 
        or set gcc linker flags      =  gcc ...  -Wl,-rpath,<path> ...                                            
        or follow instructions:
           ~ cat /etc/ld.so.conf     # will see 'include <path>'      = path to .conf files, using by system to find .so
           ~ cd <path> && ls         # will see list of .conf files   = every .conf describes path to directories with .so files
           > varinats:
             or add your own .conf file with path to dir with your .so
             or put your .so to one of the dirs, described in one of the existing .conf files     


   7. files and filsystem

      all of manuals are in `man man`

      file = named part of disk memory
      file = system interface (memory for data exchange)

            /path/to/file
            [    data   ]  >>  metadata:
                              - date, time (create, changed ...) 
                              - rights
                              - size 
                              - ...

      info about file: stat <filepath>

      all of system calls are in `man 2 <syscall>`
      most important in this context: 
         > create and delete files    =  creat, unlink
         > work inside file           =  open, close, read, write, lseek
         > work with file descriptor  =  fctrl 
      
      directory = file of special format, including metadata of inner files and directories

      all of library calls are in `man 3 <libcall>`
      most important in this context:
         > open directory          =  opendir, fdopendir
         > get information         =  readdir
         > close directory         =  closedir

         example:

               #include <sys/stat.h>
               #include <dirent.h> 
               
               struct dirent *de = malloc(sizeof(struct dirent)); 
               struct stat *info; = malloc(sizeof(struct stat));

               DIR *dr = opendir(<dirpath>); 

               if (dr == NULL) 
               { 
                  ...
               } 
               else
               {
                  while ((de = readdir(dr)) != NULL) 
                  {
                     ...
                  }
               }

               closedir(dr);  

      link types:
      > hardlink (type = file)
         - same inode
         - both of links might be placed in any filsystem's place
         - file exists while exists at least one hardlink
         = the same file (extension of file names list) !
      > symlink (type = symbolic link) 
         - differ inode
         - if source file will be replaced, link will be broken
         - file existance independent of symlink
         = access to source file by name = not by inode !
      
      procfs (processes filesystem) = processes + equipment

         > man 1 ltrace = trace library calls
         > man 1 strace = trace system calls
         > man 1 pstree = processes tree

         > procfs =
                         interface
         1.  run process o-------<  (syscall) KERNEL ( processes handle ) >> run PROCESS ( unique PID ) 
         2.  KERNEL  >>  PROCFS drivers  >> create PROCESS FILES ( /proc/PID/file* )                                          
         3.  PROCESS FILES = process interface 
         4.  command( PID, args ) o-------< (syscall) KERNEL o-------<  PROCFS o-------< PROCESS


   8. processes, basics

      process = unit of planning (!)
         + threads
         + memory regions allowed for process usage
         + credentials (inherited from user's access rights)
      and other attributes

      process atributes: 
         > pid ( + ppid )
         > memory and registers state
         > return code
      keep in simple struct in memory - after process is ended,
      struct and process finally destroyed when parent process 
      requests for return code of process 
      
      process-zombie

      if parent of the process is destroyed before,
      the init process becomes parent


   9. fork() = create new process >> man 2 fork

      > process is copy of parent process
        differences: 
         - different PID, PPID
         - doesn't inherit memory locks
                           signals in wait state
                           timers

      > starts execution of the same binary file from the next line, but
        returns value in the child process as well. Peculiarity:
         - return value in parent process = child PID
         - return value in chald process = 0
         - if not succeed return value in parent process = -1 


  10. exec() = number of functions to create new process >> man 3 exec
      corresponding syscall is execve() >> man 2 execve 

      > process has all of attributes are deffered from parent
      > new process replace current process
      > new process might be created as an
         - execution of executable ( = binary ) file
         - running script (in this case it requires interpretator as one of arguments)
      > if execve() failed :
         - return code = -1
         - errno is set to appropriate error state


   11. clone() = create new process with particular attributes >> man 2 clone

      > process is copy of parent process, but 
        state of some attributes might be set manually:
         - open files
         - file namespace ( process' root filesystem = part of entire filesystem )
         - input-output operations
         - network environment, hostname
         - processes identificators spaces (container virtualization)
         - memory and registers
         - ...

 
   12. daemons

      order to create daemon:

      [a] in parent process
          > fork() = create child process
          > do logic or kill parent process
      [b] in child process:
          > setsid()             =  create new session ID for daemon process (parent process would be 'systemd')
          > umask(int)           =  give necessary permissions 
          > chdir("dirpath")     =  go to necessary directory
          > signal( ... )        =  setup signals handlers
          > close( ... )         =  close std input, output, error (+ and all files as well)
      
      or [man 3 daemon] might be used to detach current process from 
      the controlling terminal and run in the background as system daemons

   13. tasks for 'Processes and treads are done'

   14. IPC = inter-process communication, local

       [A] = (un)named pipes

         pipe and read(): 
         
            1. after READER opened pipe, pipe is in blocking mode, until WRITER open the same pipe
            2. while WRITER and READER are on the same pipe, read() works in such mode:
               > read data from pipe, if there are in it
               > wait for data, if pipe is empty
            3. after WRITER closes pipe and READER is alone, read() returns 0 value
         
         flow:
         
         >  READER opens pipe 
         >  READER is in blocking mode
         >                                   WRITER opens pipe
         >  READER unblocked
         >  ------------------------- loop ----------------------------
            read() waits for data in pipe 
                                             write() sends data to pipe
            read() gets data from pipe
            -----------------------------------------------------------
         >                                   WRITER closes pipe
         >  read() worsk in regular mode
         >  read() gets 0 value

         best way to use special read() mode is to put it into while loop:
         while( read( ... ) ) ...      so if WRITER closes pipe, loop ends

      ! named pipe might be opened by READER in read-write mode =
        so there are always one fictive writer and real writers might
        come ane leave in any time without effecting to read() behavior

       [B] = message queues (man mq_open , man mq_send , ... )

       [C] = signals

       [D] = shared memory

       [E] = POSIX semaphore

       [F] = RPC = remote procedure call (man rpc)

   15. IPC = inter-process communication, network